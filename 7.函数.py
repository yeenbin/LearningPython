#Python 内置了很多有用的函数 我们可以直接调用。
print(abs(-20))

# abs(1,2) #TypeError: abs() takes exactly one argument

# abs('a') #TypeError: bad operand type for abs(): 'str'


#而max函数max()可以接收任意多个参数，并返回最大的那个
print(max(1,2,3,10,-3))


#数据类型的转换
print(int('123'))
print(int(12.34))

print(float('33.45'))

print(str(12.34))


#函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”

a = abs #变量a指向abs函数

print(a(-10))



#-------------定义函数-----------------
print('-------------定义函数-----------------')

#在Python ，定义一个函数要使用def语句、依次写出函数名、括号、括号中的参数和冒号：
def my_abs(x):
	if not isinstance(x,(int,float)):
		raise TypeError('bad operand type')
	if x >= 0:
		return x
	else:
		return -x

print(my_abs(11))
print(my_abs(-11))


#请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。

# 如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。



# 如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名

# 定义一个什么事页不做的空函数
def nop():
	pass

#pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。


# 传入错误的参数
# my_abs('a')

#我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。



# 返回多个值的函数
#比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的新的坐标

import math

def move(x,y,step, angle=0):
	nx = x + step * math.cos(angle)
	ny = y - step * math.sin(angle)
	return nx,ny


r = move(100, 100, 60, math.pi / 6)
print(r)

# 原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。

# 小结

# 定义函数时，需要确定函数名和参数个数；

# 如果有必要，可以先对参数的数据类型做检查；

# 函数体内部可以用return随时返回函数结果；

# 函数执行完毕也没有return语句时，自动return None。

# 函数可以同时返回多个值，但其实就是一个tuple。


#-------------函数的参数-----------------
print('-------------函数的参数-----------------')

#Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码

# 位置参数
#定义一个函数power(x, n) 用来计算x的n次方
def power(x,n = 2):
	s = 1
	while n > 0:
		n -= 1
		s = s * x
	return s

print(power(5,2))
print(power(5,3))

#power(x, n)函数有两个参数：x和n，这两个参数都是位置参数


#power(x, n = 2)  默认参数


#从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：

# 一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；

# 二是如何设置默认参数。

# 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。

#为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。

#------------可变参数

#定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：

def calc(*numbers):
	sum = 0
	for n in numbers:
		sum = sum + n * n
	return sum


print(calc())
print(calc(1,2,3))
print(calc(1,3,5,7))


#*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。
nums = [1, 2, 3]
print(calc(*nums))


#----------关键字参数
#可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。
def person(name,age,**kw):
	print('my name is ', name, 'my age is',age, 'other:', kw)

print(person('yeenbin',28))

print(person('yeenbin',28,gender='M'))


#关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。


#如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：

#命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。
def person(name,age,*,city,job):
	print(name,age,city,job)


person('Jack',24,city = 'Beijing',job = 'Engineer')
#命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：

#使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：



#----------------参数组合
#在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。


#*args是可变参数，args接收的是一个tuple；
# **kw是关键字参数，kw接收的是一个dict。

# 以及调用函数时如何传入可变参数和关键字参数的语法：

# 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；

# 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。

# 使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。

# 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。

# 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。



#-------------递归函数-----------------
print('-------------递归函数-----------------')

#在函数内部，可以调用其他的函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。

#例如计算n阶乘 n! = 1x2x3.....n,

def fact(n):
	if n==1:
		return 1
	return n *fact(n-1)


print(fact(3))
print(fact(5))
print(fact(100))

#递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式的
#使用递归函数需要注意防止栈溢出，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层的栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)

# fact(1000)

# 解决递归栈溢出的方法是通过尾递归优化，
# 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现的栈溢出的情况。

#修改n阶乘为尾递归

def fact(n):
	return fact_iter(n,1)

def fact_iter(num,product):
	if num == 1:
		return product
	return fact_iter(num - 1,num * product)

# print(fact(1000))

#遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以上面优化过的函数还是会栈溢出。


